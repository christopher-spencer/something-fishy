"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.e2eProjectGeneratorInternal = exports.e2eProjectGenerator = void 0;
const devkit_1 = require("@nx/devkit");
const project_name_and_root_utils_1 = require("@nx/devkit/src/generators/project-name-and-root-utils");
const eslint_1 = require("@nx/eslint");
const global_eslint_config_1 = require("@nx/eslint/src/generators/init/global-eslint-config");
const path = require("path");
const versions_1 = require("../../utils/versions");
const eslint_file_1 = require("@nx/eslint/src/generators/utils/eslint-file");
const log_show_project_command_1 = require("@nx/devkit/src/utils/log-show-project-command");
async function e2eProjectGenerator(host, options) {
    return await e2eProjectGeneratorInternal(host, {
        addPlugin: false,
        projectNameAndRootFormat: 'derived',
        ...options,
    });
}
exports.e2eProjectGenerator = e2eProjectGenerator;
async function e2eProjectGeneratorInternal(host, _options) {
    const tasks = [];
    const options = await normalizeOptions(host, _options);
    const appProject = (0, devkit_1.readProjectConfiguration)(host, options.project);
    // TODO(@ndcunningham): This is broken.. the outputs are wrong.. and this isn't using the jest generator
    (0, devkit_1.addProjectConfiguration)(host, options.e2eProjectName, {
        root: options.e2eProjectRoot,
        implicitDependencies: [options.project],
        projectType: 'application',
        targets: {
            e2e: {
                executor: '@nx/jest:jest',
                outputs: ['{workspaceRoot}/coverage/{e2eProjectRoot}'],
                options: {
                    jestConfig: `${options.e2eProjectRoot}/jest.config.ts`,
                    passWithNoTests: true,
                },
            },
        },
    });
    if (options.projectType === 'server') {
        (0, devkit_1.generateFiles)(host, path.join(__dirname, 'files/server/common'), options.e2eProjectRoot, {
            ...options,
            ...(0, devkit_1.names)(options.rootProject ? 'server' : options.project),
            offsetFromRoot: (0, devkit_1.offsetFromRoot)(options.e2eProjectRoot),
            tmpl: '',
        });
        if (options.isNest) {
            (0, devkit_1.generateFiles)(host, path.join(__dirname, 'files/server/nest'), options.e2eProjectRoot, {
                ...options,
                ...(0, devkit_1.names)(options.rootProject ? 'server' : options.project),
                offsetFromRoot: (0, devkit_1.offsetFromRoot)(options.e2eProjectRoot),
                tmpl: '',
            });
        }
    }
    else if (options.projectType === 'cli') {
        const mainFile = appProject.targets.build?.options?.outputPath;
        (0, devkit_1.generateFiles)(host, path.join(__dirname, 'files/cli'), options.e2eProjectRoot, {
            ...options,
            ...(0, devkit_1.names)(options.rootProject ? 'cli' : options.project),
            mainFile,
            offsetFromRoot: (0, devkit_1.offsetFromRoot)(options.e2eProjectRoot),
            tmpl: '',
        });
    }
    // axios is more than likely used in the application code, so install it as a regular dependency.
    const installTask = (0, devkit_1.addDependenciesToPackageJson)(host, { axios: versions_1.axiosVersion }, {});
    tasks.push(installTask);
    if (options.linter === eslint_1.Linter.EsLint) {
        const linterTask = await (0, eslint_1.lintProjectGenerator)(host, {
            project: options.e2eProjectName,
            linter: eslint_1.Linter.EsLint,
            skipFormat: true,
            tsConfigPaths: [
                (0, devkit_1.joinPathFragments)(options.e2eProjectRoot, 'tsconfig.json'),
            ],
            setParserOptionsProject: false,
            skipPackageJson: false,
            rootProject: options.rootProject,
            addPlugin: options.addPlugin,
        });
        tasks.push(linterTask);
        if (options.rootProject && (0, eslint_file_1.isEslintConfigSupported)(host)) {
            (0, eslint_file_1.addPluginsToLintConfig)(host, options.e2eProjectRoot, '@nx');
            (0, eslint_file_1.replaceOverridesInLintConfig)(host, options.e2eProjectRoot, [
                global_eslint_config_1.typeScriptOverride,
                global_eslint_config_1.javaScriptOverride,
            ]);
        }
    }
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
    tasks.push(() => {
        (0, log_show_project_command_1.logShowProjectCommand)(options.e2eProjectName);
    });
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.e2eProjectGeneratorInternal = e2eProjectGeneratorInternal;
async function normalizeOptions(tree, options) {
    const { projectName: e2eProjectName, projectRoot: e2eProjectRoot } = await (0, project_name_and_root_utils_1.determineProjectNameAndRootOptions)(tree, {
        name: options.name ?? `${options.project}-e2e`,
        projectType: 'library',
        directory: options.rootProject ? 'e2e' : options.directory,
        projectNameAndRootFormat: options.rootProject
            ? 'as-provided'
            : options.projectNameAndRootFormat,
        // this is an internal generator, don't save defaults
        callingGenerator: null,
    });
    const nxJson = (0, devkit_1.readNxJson)(tree);
    const addPlugin = process.env.NX_ADD_PLUGINS !== 'false' &&
        nxJson.useInferencePlugins !== false;
    return {
        addPlugin,
        ...options,
        e2eProjectRoot,
        e2eProjectName,
        port: options.port ?? 3000,
        rootProject: !!options.rootProject,
    };
}
exports.default = e2eProjectGenerator;
