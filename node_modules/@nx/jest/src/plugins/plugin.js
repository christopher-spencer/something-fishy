"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = exports.createDependencies = void 0;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const get_named_inputs_1 = require("@nx/devkit/src/utils/get-named-inputs");
const fs_1 = require("fs");
const jest_config_1 = require("jest-config");
const cache_directory_1 = require("nx/src/utils/cache-directory");
const calculate_hash_for_create_nodes_1 = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const config_utils_1 = require("@nx/devkit/src/utils/config-utils");
const package_json_workspaces_1 = require("nx/src/plugins/package-json-workspaces");
const globs_1 = require("nx/src/utils/globs");
const minimatch_1 = require("minimatch");
const cachePath = (0, path_1.join)(cache_directory_1.projectGraphCacheDirectory, 'jest.hash');
const targetsCache = (0, fs_1.existsSync)(cachePath) ? readTargetsCache() : {};
const calculatedTargets = {};
function readTargetsCache() {
    return (0, devkit_1.readJsonFile)(cachePath);
}
function writeTargetsToCache(targets) {
    (0, devkit_1.writeJsonFile)(cachePath, targets);
}
const createDependencies = () => {
    writeTargetsToCache(calculatedTargets);
    return [];
};
exports.createDependencies = createDependencies;
exports.createNodes = [
    '**/jest.config.{cjs,mjs,js,cts,mts,ts}',
    async (configFilePath, options, context) => {
        const projectRoot = (0, path_1.dirname)(configFilePath);
        const packageManagerWorkspacesGlob = (0, globs_1.combineGlobPatterns)((0, package_json_workspaces_1.getGlobPatternsFromPackageManagerWorkspaces)(context.workspaceRoot));
        // Do not create a project if package.json and project.json isn't there.
        const siblingFiles = (0, fs_1.readdirSync)((0, path_1.join)(context.workspaceRoot, projectRoot));
        if (!siblingFiles.includes('package.json') &&
            !siblingFiles.includes('project.json')) {
            return {};
        }
        else if (!siblingFiles.includes('project.json') &&
            siblingFiles.includes('package.json')) {
            const path = (0, devkit_1.joinPathFragments)(projectRoot, 'package.json');
            const isPackageJsonProject = (0, minimatch_1.minimatch)(path, packageManagerWorkspacesGlob);
            if (!isPackageJsonProject) {
                return {};
            }
        }
        const jestConfigContent = (0, fs_1.readFileSync)((0, path_1.resolve)(context.workspaceRoot, configFilePath), 'utf-8');
        if (jestConfigContent.includes('getJestProjectsAsync()')) {
            // The `getJestProjectsAsync` function uses the project graph, which leads to a
            // circular dependency. We can skip this since it's no intended to be used for
            // an Nx project.
            return {};
        }
        options = normalizeOptions(options);
        const hash = (0, calculate_hash_for_create_nodes_1.calculateHashForCreateNodes)(projectRoot, options, context);
        const { targets, metadata } = targetsCache[hash] ??
            (await buildJestTargets(configFilePath, projectRoot, options, context));
        calculatedTargets[hash] = { targets, metadata };
        return {
            projects: {
                [projectRoot]: {
                    root: projectRoot,
                    targets,
                    metadata,
                },
            },
        };
    },
];
async function buildJestTargets(configFilePath, projectRoot, options, context) {
    const absConfigFilePath = (0, path_1.resolve)(context.workspaceRoot, configFilePath);
    if (require.cache[absConfigFilePath]) {
        (0, config_utils_1.clearRequireCache)();
    }
    const config = await (0, jest_config_1.readConfig)({
        _: [],
        $0: undefined,
    }, absConfigFilePath);
    const namedInputs = (0, get_named_inputs_1.getNamedInputs)(projectRoot, context);
    const targets = {};
    const target = (targets[options.targetName] = {
        command: 'jest',
        options: {
            cwd: projectRoot,
        },
        metadata: {
            technologies: ['jest'],
            description: 'Run Jest Tests',
        },
    });
    const cache = (target.cache = true);
    const inputs = (target.inputs = getInputs(namedInputs));
    const outputs = (target.outputs = getOutputs(projectRoot, config, context));
    let metadata;
    if (options?.ciTargetName) {
        // Resolve the version of `jest-runtime` that `jest` is using.
        const jestPath = require.resolve('jest');
        const jest = require(jestPath);
        // nx-ignore-next-line
        const { default: Runtime } = require(require.resolve('jest-runtime', {
            paths: [(0, path_1.dirname)(jestPath)],
            // nx-ignore-next-line
        }));
        const jestContext = await Runtime.createContext(config.projectConfig, {
            maxWorkers: 1,
            watchman: false,
        });
        const source = new jest.SearchSource(jestContext);
        const specs = await source.getTestPaths(config.globalConfig);
        const testPaths = new Set(specs.tests.map(({ path }) => path));
        if (testPaths.size > 0) {
            const groupName = 'E2E (CI)';
            const targetGroup = [];
            metadata = {
                targetGroups: {
                    [groupName]: targetGroup,
                },
            };
            const dependsOn = [];
            targets[options.ciTargetName] = {
                executor: 'nx:noop',
                cache: true,
                inputs,
                outputs,
                dependsOn,
                metadata: {
                    technologies: ['jest'],
                    description: 'Run Jest Tests in CI',
                },
            };
            targetGroup.push(options.ciTargetName);
            for (const testPath of testPaths) {
                const relativePath = (0, path_1.normalize)((0, path_1.relative)((0, path_1.join)(context.workspaceRoot, projectRoot), testPath));
                const targetName = `${options.ciTargetName}--${relativePath}`;
                dependsOn.push(targetName);
                targets[targetName] = {
                    command: `jest ${relativePath}`,
                    cache,
                    inputs,
                    outputs,
                    options: {
                        cwd: projectRoot,
                    },
                    metadata: {
                        technologies: ['jest'],
                        description: `Run Jest Tests in ${relativePath}`,
                    },
                };
                targetGroup.push(targetName);
            }
        }
    }
    return { targets, metadata };
}
function getInputs(namedInputs) {
    return [
        ...('production' in namedInputs
            ? ['default', '^production']
            : ['default', '^default']),
        {
            externalDependencies: ['jest'],
        },
    ];
}
function getOutputs(projectRoot, { globalConfig }, context) {
    function getOutput(path) {
        const relativePath = (0, path_1.relative)((0, path_1.join)(context.workspaceRoot, projectRoot), path);
        if (relativePath.startsWith('..')) {
            return (0, path_1.join)('{workspaceRoot}', (0, path_1.join)(projectRoot, relativePath));
        }
        else {
            return (0, path_1.join)('{projectRoot}', relativePath);
        }
    }
    const outputs = [];
    for (const outputOption of [
        globalConfig.coverageDirectory,
        globalConfig.outputFile,
    ]) {
        if (outputOption) {
            outputs.push(getOutput(outputOption));
        }
    }
    return outputs;
}
function normalizeOptions(options) {
    options ??= {};
    options.targetName ??= 'test';
    return options;
}
